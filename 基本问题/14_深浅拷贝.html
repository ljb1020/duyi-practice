<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

</body>
<script>

  let obj1 = {
    name: "zhangsan",
    age: 17,
    parents: ["father", "mather"]
  }

  // 浅拷贝
  function shallowClone(obj) {
    const newObj = {};
    for (let prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        newObj[prop] = obj[prop];
      }
    }
    return newObj;
  }

  // 深拷贝


  function deepClone(obj) {
    // 如果是 null 或者不是对象/数组，直接返回原始值
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }
    // 根据原始值是数组还是对象，创建一个空的拷贝容器
    const clone = Array.isArray(obj) ? [] : {};
    // 递归拷贝每一个属性
    for (let key of Object.keys(obj)) {
      clone[key] = deepClone(obj[key]);
    }
    return clone;
  }

  function deepClone2(obj) {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    const clone = Array.isArray(obj) ? [] : {};

    for (let key of Object.keys(obj)) {
      clone[key] = deepClone(obj[key]);
    }
  }

  function deepClone1(obj) {
    // 如果是 null 或者不是对象/数组，直接返回原始值
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    // 根据原始值是数组还是对象，创建一个空的拷贝容器
    const clone = Array.isArray(obj) ? [] : {};

    // 递归拷贝每一个属性
    for (let key in obj) {
      if (obj.hasOwnProperty(key)) {
        clone[key] = deepClone(obj[key]);
      }
    }

    return clone;
  }


  obj2 = shallowClone(obj1);
  obj3 = JSON.parse(JSON.stringify(obj1))  //但是这种方式存在弊端，会忽略undefined、symbol和函数
  obj4 = deepClone(obj1)
  obj1.age = 999;
  obj1.parents.pop();



  console.log(obj1, obj2, obj3, obj4);

</script>

</html>